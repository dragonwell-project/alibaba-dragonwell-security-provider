import org.ajoberstar.grgit.Grgit
import org.gradle.util.VersionNumber
import java.util.concurrent.TimeUnit

buildscript {
    ext.errorproneVersion = '2.4.0'
    ext.errorproneJavacVersion = '9+181-r4173-1'
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        // This must be applied in the root project otherwise each subproject will
        // have it in a different ClassLoader.
        classpath 'biz.aQute.bnd:biz.aQute.bnd.gradle:4.3.0'
    }
}

plugins {
    // Add dependency for build script so we can access Git from our
    // build script.
    id 'org.ajoberstar.grgit' version '3.1.1'
    id 'net.ltgt.errorprone' version '1.3.0'
    id "com.google.osdetector" version "1.7.3"
}

subprojects {
    apply plugin: 'java-library'
    apply plugin: 'cpp'
    model {
        toolChains {
            // Prefer Clang over Gcc (order here matters!)
            clang(Clang) {
                target("osx_aarch64") {
                    cppCompiler.withArguments { args ->
                        args << "-arch" << "arm64"
                    }
                    linker.withArguments { args ->
                        args << "-arch" << "arm64"
                    }
                }
                target("linux_aarch64") {
                    cppCompiler.withArguments { args ->
                        args << "-arch" << "arm64"
                    }
                    linker.withArguments { args ->
                        args << "-arch" << "arm64"
                    }
                }
            }
            gcc(Gcc)
        }
    }
    apply plugin: "idea"
    apply plugin: "jacoco"
    apply plugin: "net.ltgt.errorprone"

    group = "com.alibaba.dragonwell"
    description = 'Dragonwell Security is an alternate High Performance Java Security Provider'
    version = "1.0.0"

    ext {
        if (project.hasProperty("tongsuoHome")) {
            tongsuoHome = project.property("tongsuoHome")
        } else {
            tongsuoHome = "$System.env.TONGSUO_HOME"
        }

        tongsuoIncludeDir = normalizePath("$tongsuoHome/include")
        archBuild = libDir()
        tongsuoExecutePath = normalizePath("$tongsuoHome/$archBuild/bin/openssl")
        tongsuoLibPath = normalizePath("$tongsuoHome/$archBuild/lib")
        tongsuoPathProp = "test.babassl.path"
        tongsuoLibPathProp = "test.babassl.lib.path"
        opensslPathProp = "test.openssl.path"
        opensslLibPathProp = "test.openssl.lib.path"

        // Ensure the environment is configured properly.
        assert file("$tongsuoIncludeDir").exists()

        // Get the commit hash for Tongsuo.
        tongsuoGit = Grgit.open(dir: tongsuoHome)
        tongsuoVersion = tongsuoGit.head().id

        jmhVersion = '1.21'
        libraries = [
                // Test dependencies.
                bouncycastle_apis: 'org.bouncycastle:bcpkix-jdk15on:1.63',
                bouncycastle_provider: 'org.bouncycastle:bcprov-jdk15on:1.63',
                junit  : 'junit:junit:4.13.2',
                mockito: 'org.mockito:mockito-core:2.28.2',
                truth  : 'com.google.truth:truth:1.0',

                // Benchmark dependencies
                jmh_core: "org.openjdk.jmh:jmh-core:${jmhVersion}",
                jmh_generator_annprocess: "org.openjdk.jmh:jmh-generator-annprocess:${jmhVersion}",
                jmh_generator_asm: "org.openjdk.jmh:jmh-generator-asm:${jmhVersion}",
                jmh_generator_bytecode: "org.openjdk.jmh:jmh-generator-bytecode:${jmhVersion}",
                jmh_generator_reflection: "org.openjdk.jmh:jmh-generator-reflection:${jmhVersion}",
                netty_handler: 'io.netty:netty-handler:4.1.24.Final',
                netty_tcnative: 'io.netty:netty-tcnative-boringssl-static:2.0.26.Final',
        ]

        signJar = { jarPath ->
            if (rootProject.hasProperty('signingKeystore') && rootProject.hasProperty('signingPassword')) {
                def command = 'jarsigner -keystore ' + rootProject.signingKeystore +
                        ' -storepass ' + rootProject.signingPassword +
                        ' ' + jarPath + ' signingcert'
                def process = command.execute()
                process.waitFor()
                if (process.exitValue()) {
                    throw new RuntimeException('Jar signing failed for ' + jarPath + ': ' + process.text)
                }
            }
        }
    }

    repositories {
        mavenCentral()
        mavenLocal()
    }

    jacoco {
        toolVersion = "0.8.4"
    }

    dependencies {
        errorprone("com.google.errorprone:error_prone_core:$errorproneVersion")
        errorproneJavac("com.google.errorprone:javac:$errorproneJavacVersion")
    }

    tasks.register("generateProperties", WriteProperties) {
        ext {
            parsedVersion = VersionNumber.parse(version)
        }
        property("com.alibaba.dragonwell.security.version.major", parsedVersion.getMajor())
        property("com.alibaba.dragonwell.security.version.minor", parsedVersion.getMinor())
        property("com.alibaba.dragonwell.security.version.patch", parsedVersion.getMicro())
        property("com.alibaba.dragonwell.security.tongsuo.version", tongsuoVersion)
        outputFile "build/generated/resources/com/alibaba/dragonwell/security/dragonwell_security.properties"
    }

    java {
        toolchain {
            // Compile with a real JDK 8 so we don't end up with accidental dependencies
            // on Java 11 bootclasspath, e.g. ByteBuffer.flip().
            languageVersion = JavaLanguageVersion.of(8)
        }
    }
    [tasks.named("compileJava"), tasks.named("compileTestJava")].forEach { t ->
        t.configure {
            options.compilerArgs += ["-Xlint:all", "-Xlint:-options", '-Xmaxwarns', '9999999']
            options.encoding = "UTF-8"
            if (rootProject.hasProperty('failOnWarnings') && rootProject.failOnWarnings.toBoolean()) {
                options.compilerArgs += ["-Werror"]
            }
        }
    }
    tasks.named("compileTestJava").configure {
        // serialVersionUID is basically guaranteed to be useless in our tests
        options.compilerArgs += ["-Xlint:-serial"]
    }
    tasks.named("jar").configure {
        manifest {
            attributes('Implementation-Title': name,
                    'Implementation-Version': archiveVersion,
                    'Built-By': System.getProperty('user.name'),
                    'Built-JDK': System.getProperty('java.version'),
                    'Source-Compatibility': sourceCompatibility,
                    'Target-Compatibility': targetCompatibility)
        }
    }
    javadoc.options {
        encoding = 'UTF-8'
        links 'https://docs.oracle.com/javase/8/docs/api/'
    }
    // All non-Android projects build with Java 8, so disable doclint as it's noisy.
    allprojects {
        tasks.withType(Javadoc) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }
    tasks.register("javadocJar", Jar) {
        classifier = 'javadoc'
        from javadoc
    }
    tasks.register("sourcesJar", Jar) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }
    // At a test failure, log the stack trace to the console so that we don't
    // have to open the HTML in a browser.
    test {
        testLogging {
            exceptionFormat = 'full'
            showExceptions true
            showCauses true
            showStackTraces true
            showStandardStreams = true
        }
        // Enable logging for all conscrypt classes while running tests.
        systemProperty 'java.util.logging.config.file', "${rootDir}/test_logging.properties"
        maxHeapSize = '1500m'

        filter {
            if (!isTongsuoAvailable(tongsuoExecutePath, tongsuoLibPath)) {
                // Ignore BabaSSL-related tests if no BabaSSL is available
                excludeTestsMatching("*BabaSSL*Test")
            } else {
                systemProperty "${tongsuoPathProp}", "${tongsuoExecutePath}"
                systemProperty "${opensslPathProp}", "${tongsuoExecutePath}"
                systemProperty "${tongsuoLibPathProp}", "${tongsuoLibPath}"
                systemProperty "${opensslLibPathProp}", "${tongsuoLibPath}"
            }
        }
    }
}

static String normalizePath(path) {
    new File(path.toString()).absolutePath
}

// Determine if Tongsuo is available
boolean isTongsuoAvailable(String tongsuoPath, String tongsuoLibPath) {
    int exitCode = -1
    try {
        ProcessBuilder processBuild = new ProcessBuilder(tongsuoPath, "version")
        processBuild.environment().put(ldKey(), tongsuoLibPath)
        Process process = processBuild.start()
        process.waitFor(3, TimeUnit.SECONDS)
        exitCode = process.exitValue()
    } catch (Exception e) {
        println("Tongsuo is unavailable: " + e.cause)
    }

    return exitCode == 0
}

// Determine if archetecture is x64 or arm64
String libDir() {
    String arch = "${osdetector.arch}"
    if (arch == "aarch_64") {
        return "build.arm64"
    } else if (arch == "x86_64") {
        return "build.x64"
    } else {
        return "";
    }
}

// Determine which LD_LIBRARY_PATH should be added as map key
String ldKey() {
    String os = "${osdetector.os}"
    if (os == "osx") {
        return "DYLD_LIBRARY_PATH"
    } else if (os == "linux") {
        return "LD_LIBRARY_PATH"
    } else {
        return "";
    }
}
